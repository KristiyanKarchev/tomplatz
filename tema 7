-----------------------------------------------------------------------------


Целта на задачата е да можете да различавате видовете алгоритми. На картинките са показани два алгоритъма. Срещу всяка една от картинките трябва да попълните кой от видовете алгоритми е използван

var list = Console.ReadLine().Split().Select(int.Parse).ToArray();
int start = 0, end = list.Length;
int key =5;
var flag = false;
while (end >= start)
{
int mid = (start + end) / 2;                     → Алгоритъм за търсене на елемент в масив. Използван е алгоритъма двоично търсене.,
if (list[mid] < key)
start = mid - 1;
else
{


var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)
{
for (int i = 0; i <= list.Count - 2; i++)                  → Алгоритъм за сортиране на елементите в масив. Използван е алгоритъма за сортиране чрез
{
if (list[i] > list[i + 1])

-----------------------------------------------------------------------------

Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез метода на мехурчето.

 public static void BubbleSortWithFor(List<int> list)
        {
            for (int j = 0; j <= list.Count - 2; j++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] > list[i + 1])
                    {
                        Swap(list, i, i + 1);
                    }
                }
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }

-----------------------------------------------------------------------------

Дайте пример за това къде можете да срещнете поведението на структурата от данни опашка във вашето ежедневие. И обяснете защо.

Пример : Например опашка от хора, чакащи на каса за билети. Опашката има начало и край. Новодошлите хора застават последни на опашката и изчакват докато постепенно се придвижат към началото. Когато стигнат до самото начало на опашката си купуват билет и напускат опашката. 

Пример 2: Други примери за опашка са документи, чакащи да бъдат отпечатани.

Пример 3: Ескалатор превозващ хора. По този начин опашката изпълнява функцията на буфер.

Защото: Структурата от данни опашка изпълнява условието „първият влязъл първи излиза“ (FIFO: First-In-First-Out). Това означава, че след като е добавен един елемент в края на опашката, той ще може да бъде извлечен (премахнат) единствено след като бъдат премахнати всички елементи преди него в реда, в който са добавени.

-----------------------------------------------------------------------------

Показани са означенията на типовете сложност на алгоритъм, посочете съответстващата му сложност, като изберете от падащия списък срещу всяко от означенията:

O(n3)        [кубична]

O(log(N))  [логаритмична]

O(N)         [линейна]

O(2n)        [експоненциална]

О(n2)        [квадратична]

O(1)          [константна]

O(N!)        [експоненциална]

-----------------------------------------------------------------------------

Обяснете какво прави методът Enqueue(T)?

Правилният отговор е: добавя елемент в края на опашката

-----------------------------------------------------------------------------

Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var collection = Console.ReadLine().Split().Select(int.Parse).ToList(); //2т
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] < collection[min])//2т
                    {
                        min = curr;
                    }
                }               
                int temp = collection[index]; //2т
                collection[index] = collection[min];
                collection[min] = temp; //2т
            }
            Console.WriteLine(string.Join(" ", collection));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

-----------------------------------------------------------------------------

Изчислете какъв ще бъде отговорът на следния пример:

През 2013 ООН има 193 страни членки. Ако имената на тези страни са сортирани по азбучен ред в масив, колко имена трябва да провери двоичното търсене, за да намери конкретно име в масива в най-лошия случай?

[Не повече от 8.]

-----------------------------------------------------------------------------


Имате даден програмен фрамент от код написан на C#.


using System;
 
namespace Sequence
{
    class Program
    {
       static void LongestSequenceEqualNumbers()
        {
            //List<int> nums = Console.ReadLine().Split().ToList(); //2т
            List<int> nums = Console.ReadLine().Split().Select(int.Parse).ToList();

            //int bestStart = 0 //2т
            int bestStart = 0;
            int bestLength = 1;
            int currentLength = 1;
            int index = 0;
            int first = nums[index];

            for (int i = 1; i < nums.Count; i++)
            {
                if (first == nums[i])
                {
                    currentLength++;
                    if (currentLength > bestLength)
                    {
                        bestLength = currentLength;
                        //bestStart = index; //2т
                        bestStart = index;
                    }
                }
                else
                {
                    first = nums[i];
                    index = i;
                    //currentLength = 1; //2т
                    currentLength = 1;
                }
            }

            for (int i = bestStart; i < bestStart + bestLength; i++)
            {
                Console.Write($"{nums[i]} ");
            }
        }

Съставете програма, която намира най-дългата последователност от равни числа в даден списък от цели числа List<int>  
и отпечатва като резултат тази най-дълга последователност. Ако няколко поредици имат същата най-дълга дължина, върнете най-лявата от тях.
Вход
Изход
12 2 7 4 3 3 8
3 3
2 2 2 3 3 3
2 2 2
4 4 5 5 5
5 5 5

-----------------------------------------------------------------------------

Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var collection = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] < collection[min]) //2т
                    {
                        min = curr;
                    }
                }               
                int temp = collection[index]; //2т
                collection[index] = collection[min];
                collection[min] = temp; //2т
            }
            Console.WriteLine(string.Join(" ", collection));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

-----------------------------------------------------------------------------

Обяснете какво прави методът Dequeue()?

Правилният отговор е: премахва и връща елемента от началото на опашката

-----------------------------------------------------------------------------

Имате зададени твърдения за два алгоритъма за търсене - двоично търсене и интерполационно търсене. По зададените твърдения и характеристики трябва да сравните двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:

Стойностите в масива трябва да са сортирани и равномерно разпределени. [Интерполационно търсене]

Работи във времева сложност O(log n). [Двоично търсене]

Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [Отнася се и за двата алгоритъма]

Работи във времева сложност O(log(log n)). [Интерполационно търсене] 

Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [Отнася се и за двата алгоритъма]

Може да се оцени позицията на стойността на ключа в масива,като се вземат предвид най-малкият и най-големият елемент в масива и дължината на масива. [Интерполационно търсене]

Оценява средната позиция за масива и сравнява този елемент с желания ключ. [Интерполационно търсене]

Ако ключът съвпада със средния елемент, върнете средното местоположение. [Отнася се и за двата алгоритъма]


-----------------------------------------------------------------------------

Имате следния програмен фрагмент:

private static long Sum(int n, int m)
{
long sum = 0;
for (int x = 1; x <= n; x++)
{
for (int y = 1; y <= m; y++)
{
sum += x * y;
}

Каква ще бъде сложността на алгоритъма и обяснете защо?

Ако имаме два вложени цикъла съответно от 1 до N и от 1 до M, сложността им е квадратична – O(N*М)

-----------------------------------------------------------------------------

Дадени са следните картинки:


				

Това е визуализация на един от алгоритмите за сортиране. За този алгоритъм важи следното правило: 
Масивът с несортирани елементи се разделя на две части: в едната част са сортираните елементи, в другата част са несортираните елементи. В случая числото 29 се предполага, че е в сортираната част, а числата от 10 до 6 - в несортираната. При всяка стъпка се взема първият елемент от несортираните елементи (в случая числото 10) сравнява го с предходните елементи и се поставя на правилната позиция в сортираната част на масива (в случая преди числото 29). На следващата стъпка първото число от несортирания масив е числото 14, взема това число и го поставя на правилната позиция в сортирания масив (между числата 10 и 29). Алгоритъма продължава докато елементите в несортираната част на масива се изчерпят.
Посочете кой от видовете алгоритми е използван:

Изберете едно
a. Сортиране на елементите чрез пряка селекция.
b. Сортиране на елементите чрез броене.
c. Сортиране на елементите чрез метода на мехурчето.
d. Сортиране на елементите чрез вмъкване.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

-----------------------------------------------------------------------------

Class CustomQueue<T>
{
private class QueueNode<T>
На картинката е показана част от имплементацията на линейната структура от данни опашка. Посочете коя имплементация е използвана:

Изберете едно
a. Дървовидна имплементация на опашка
b. Динамична имплементация на опашка<<<<<<<<<<<<<<<<<<<<<<<<<<
c. Имплементация на опашка чрез списък
d. Статична имплементация на опашка


-----------------------------------------------------------------------------

Имате даден следния програмен фрагмент:

public T Pop(int index)
        {
            if (this.Count == 0)
            {
                throw new InvalidOperationException("Empty stack");
            }
            T element = this.items[index]; 
            T[] temp = new T[this.items.Length];
            for (int i = 0; i < this.Count; i++)
            {
                temp[i] = this.items[i];
            } 
            this.items = temp;
            return element;
        }


Този фрагмент е част от имплементацията на линейната структура от данни стек - премахване на елемент от стек. В кода има грешка! Вашата задача е да анализирате този фрагмент от код и да идентифицирате и поправите правилно грешките в написания програмен код, така че да реши поставената задача. Да допълните кода, ако и когато това е необходимо.

В полето за въвеждане записвате:

1. Вашият анализ на грешката и това как може да бъде поправено. 

2. Редактиран и правилно работещ код.

Грешката в кода е, че методът Pop(int index) получава цяло число, което вътре в метода се използва за намиране на елемента в масива и премахването на този елемент. 
По дефиниция линейната структура стек не работи така. Правилото за работа със стек е "първи влиза - първи излиза". Нямаме право да достъпваме елементите по индекс, 
освен само и единствено за четене. Когато правим имплементацията за премахване на елемент от стек винаги премахваме последния елемент - в случая трябва да 
използваме броя на елементите (Count) на мястото на параметъра Index, за да премахнем последния елемент от масива в класа. И самия метод Pop() не трябва да приема параметър.//2т

public T Pop()//2т
        {
            if (this.Count == 0)
            {
                throw new InvalidOperationException("Empty stack");
            }
            this.Count--;//2т
            T element = this.items[this.Count];//2т

            T[] temp = new T[this.items.Length];
            for (int i = 0; i < this.Count; i++)
            {
                temp[i] = this.items[i];
            }

            this.items = temp;
            return element;
        }

-----------------------------------------------------------------------------

Имате зададени твърдения за два алгоритъма за търсене - двоично търсене и линейно търсене. По зададените твърдения и характеристики трябва да сравните двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:

Стойностите в масива трябва да са сортирани. [Двоично търсене]

Работи във времева сложност O(log n). [Двоично търсене]

Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [Двоично търсене]

Работи във времева сложност O(log(log n)). [Линейно търсене] 

Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [Двоично търсене]

Стойностите в масива не е задължително да са сортирани. [Линейно търсене]

Започва винаги от началото на масива. [Линейно търсене]

Ако ключът съвпада със средния елемент, върнете средното местоположение. [Двоично търсене]

Започва търсенето от средата на масива. [Двоично търсене]

-----------------------------------------------------------------------------

Дефинирайте понятието сложност на алгоритъм, като попълните липсващите думи в текста.

Сложност на алгоритъм е [груба оценка на броя стъпки], които алгоритъмът ще направи в зависимост от [размера на входните данни]. 
Това е груба оценка, която се интересува от [порядъка на броя стъпки], а не от [точния им брой].

-----------------------------------------------------------------------------

Посочете вярното за следното твърдение:
[Enqueue] – добавя елемент в края на опашката

-----------------------------------------------------------------------------

Ако имате следната последователност от числа: "12, 14, 24, 28, 29, 32, 36, 40, 41" и трябва да напишете алгоритъм, който да намери елемент от този списък, например числото 36. 

Като използвате алгоритъма за двоично търсене обяснете последователността от стъпки, които трябва да се изпълнят за да намерите търсеното число. 

А какво ще се случи, ако търсеното число не е в списъка?


Алгоритъма за двоично търсене работи само и единствено със сортирани елементи, като разделя масива на две части. Ако търсеното число съвпада със средния елемент,тогава алгоритъма връща индекса на средния елемент. 

Ако търсеното число е по-голямо от средния елемент, тогава  търсеното число стои в дясната половина на масива. Тогава разделяме дясната половина отново на две части и сравняваме със средния елемент. 

Ако търсеното число е по-малко от средния елемент тогава търсим в лявата половина на масива, като отново я разделяме на две части и сравняваме със средния елемент.

Алгоритъмът се повтаря докато открием търсения елемент.

Ако x не съвпада с нито един от елементите, връщаме -1.


-----------------------------------------------------------------------------

Имате даден следният псевдо код на алгоритъм за сортиране. Посочете кой алгоритъм за сортиране е използван:

do
swapped = false
for i = 1 to indexOfLastUnsortedElement-1
if leftElement > rightElement
swap (leftElement, rightElement)


Това е псевдо код за имплементация на алгоритъм за сортиране чрез [метода на мехурчето]

-----------------------------------------------------------------------------


Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)//2т
{
    for (int i = 0; i <= list.Count - 2; i++)
    {
        if (list[i] > list[i + 1])//2т
        {
            int temp = list[i];//2т
            list[i] = list[i+1];
            list[i+1] = temp;//2т
        }
    }
}
Console.WriteLine(string.Join(" ", list));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

-----------------------------------------------------------------------------

Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез пряка селекция

public static void SelectionSort(List<int> list)
        {
            for (int index = 0; index < list.Count; index++)
            {
                int min = index;
                for (int current = index + 1; current < list.Count; current++)
                {
                    if(list[current] < list[min])
                    {
                        min = current;
                    }
                }

                Swap(list, index, min);
            }
            
        }

private static void Swap(List<int> list, int index, int min)

        {

            int temp = list[index];

            list[index] = list[min];

            list[min] = temp;

        }


-----------------------------------------------------------------------------

На картинката е показана илюстрация на един от видовете алгоритми за сортиране. Посочете кой е той:
input data
0 4 2 2 0 0 1 1 0 1 0 2 4 2
count array
0 1 2 3 4
5 3 4 0 2
sorted data 
0 0 0 0 0 1 1 1 2 2 2 2 4 4
Изберете едно
a. Сортиране чрез метода на мехурчето (Bubble sort)
b. Сортиране чрез сливане (Merge sort)
c. Сортиране чрез броене (Counting sort)<<<<<<<<<<<<<<<<<<<<<
d. Сортиране чрез кофи (Bucket sort)

-----------------------------------------------------------------------------


Дадени са следните картинки:


	

Това е визуализация на един от алгоритмите за сортиране. За този алгоритъм важи следното правило: 
Взима първият елемент на масива (29) и го сравнява със следващия (10). В случая следващия елемент е по-малък и стойностите се разменят. След това сравнява вторият елемент, който вече е (29) със следващия (14) и тъй като 14 < 29 отново ги разменя. Алгоритъма разменя стойностите, само ако има нужда от това. Ако следващия елемент (напр. 37) е по-голям от предходния (29) тогава елементите няма да се разменят и сравняването ще продължи вече с новото по-голямо число (37) и следващият елемент (14). Продължава така, докато не подреди елементите в масива. 
Посочете кой от видовете алгоритми е използван:

Изберете едно
a. Сортиране на елементите чрез вмъкване.
b. Сортиране на елементите чрез броене.
c. Сортиране на елементите чрез метода на мехурчето.<<<<<<<<<<<<<<<<<<<<
d. Сортиране на елементите чрез пряка селекция.


-----------------------------------------------------------------------------


На картинката е показана илюстрация на един от видовете алгоритми за сортиране. Посочете кой е той:
38 27 43 3 9 82 10
trugvat edni strelki na dolu
3 9 10 27 38 43 82
Изберете едно
a. Сортиране чрез метода на мехурчето (Bubble sort)
b. Сортиране чрез кофи (Bucket sort)
c. Сортиране чрез броене (Counting sort)
d. Сортиране чрез сливане (Merge sort) <<<<<<<<<<<<<<<<<<<<<<<<<

-----------------------------------------------------------------------------


Имате следния програмен фрагмент:

private static int FindInversions(int[] array)

{

int inversions
for (int i = ©; i < array.length - 1; i++)

{

for (int j = i+ 1; J < array.Length; j++)

{
if (array[i] > array[§])
{
inversions++;
}
}
}

return inversions;


Каква ще бъде сложността на алгоритъма и обяснете защо?

Ако имаме два вложени цикъла от 1 до N, сложността им е квадратична – O(N2).

-----------------------------------------------------------------------------

Посочете за алгоритми с каква сложност се отнася следното твърдение:

Алгоритми с [константна, логаритмична и линейна] сложност са толкова бързи, че не можем да усетим забавяне, дори при относително голям размер на входните данни

-----------------------------------------------------------------------------

Имате даден следният псевдо код на алгоритъм за сортиране. Посочете кой алгоритъм за сортиране е използван:

mark first element as sorted
for each unsorted element X
‘extract’ the element X
for j = lastSortedIndex down to 0
if current element j > X
move sorted element to the right by 1

break loop and insert X here

Това е псевдо код за имплементация на алгоритъм за сортиране чрез [вмъкване]

-----------------------------------------------------------------------------

Дефинирайте понятието стабилност на сортирането.

Стабилност на сортирането - ако имаме два елемента които са равни в първоначалният масив, то във финалният те се срещат във същият ред като първоначалният масив.

Алгоритмите за стабилно сортиране използват следното правило: ако два елемента при сравнение са еднакви (като например двете петици), 
то тяхната първоначална подредба ще бъде съхранена, така че ако едната от тях е преди другата в началната подредба, то тя ще бъде първа и в крайния резултат.

-----------------------------------------------------------------------------

Целта на задачата е да можете да различавате видовете алгоритми. На картинките са показани два алгоритъма. Срещу всяка една от картинките трябва да попълните кой от видовете алгоритми е използван.

Правилният отговор е:  


var collection = new int[] { 22, 13, 4, 8, 56, 16, 36, 12, 7 };
for (int index = @; index < collection.Length; index++)
{
int min = index
for (int curr = index + 1; curr < collection.length; curr++)
{
if (collection[curr] < collection[min])
{                                                                     → Алгоритъм за сортиране на елементите в масив. Използван е алгоритъма за сортиране чрез пряка селекция., \
}
min = curr;
}
int temp = collection[index:
collection[index] = collection[min];
collection[min] = temp;
}
Console.WriteLine(string.Join(" *, collection));





var collection = new int[] { 22, 13, 4, 8, 56, 16, 36, 12, 7 };
var key = int.Parse(Console.ReadLine());
var flag = false;
for (int index =
{
index < collection.length; index++)
if (collection[index].CompareTo(key) == @)                → Алгоритъм за търсене на елемент в масив. Използван е алгоритъма линейно търсене.
{
flag = true;
Console.WriteLine(index);
}
}
if (flag)
{
Console.Writeline(-1);


-----------------------------------------------------------------------------

Имате дадени твърдения. Вие трябва да можете да различавате и сравнявате видовете структури от данни. Срещу всяко едно от тези твърдения трябва да зададете правилната структура от данни за която то се отнася.

За добавяне на елемент в структурата от данни използва операцията Push(T). [Стек]

Можем да обходим елементите в структура от данни тип опашка с  помощта на for-цикъл. [Твърдението не е вярно]

За премахване на елемент от структурата от данни използва операцията Dequeue(). [Опашка]

За премахване на елемент от структурата от данни използва операцията Pop(). [Стек]

Структура от данни, която има поведението първи влязъл първи излязъл. [Опашка]

Можем да достъп елемент от структурата от данни стек, като използваме операцията Peek(index) неговия индекс. [Твърдението не е вярно]

Структура от данни, която има поведението последен влязъл първи излязъл. [Стек]

За добавяне на елемент в структурата от данни използва операцията Enqueue(T). [Опашка]

-----------------------------------------------------------------------------

Да кажем, че играем на игра, в която трябва да познаете числото. Имате списък с числа от  1 до 20 включително подредени във възходящ ред. Решете задачата, като намерите кое е търсеното число и използвания алгоритъм за търсене на числото. 

Намислям си число и ти предполагаш, че числото е 11. Аз ти казвам, че моето число е по-малко. 

Търсиш в числата между 1 и 10. Предполагаш, че моето число е 5. Аз ти казвам, че моето число е по-малко.

Търсиш в числата между 1 и 4. Предполагаш, че моето число е 2. Аз ти казвам, че моето число е по-голямо.

Позна ли кое е моето число? [Търсеното число е 3]

Кой алгоритъм за търсене използва? [Двоично търсене]

-----------------------------------------------------------------------------

Дайте пример за това къде можете да срещнете поведението на структурата от данни стек във вашето ежедневие. И обяснете защо.

Пример 1 : Работната памет на програмата (стек) - Примитивните типове данни (числа, char, bool) се наричат стойностни типове, защото пазят непосредствено своята стойност в стека за изпълнение на програмата. 

Стекът е често срещана и използвана структура от данни. Стек се използва и вътрешно от C# виртуалната машина за съхранение на променливите в програмата и параметрите при извикване на метод.

Например една променлива, декларирана в метода Main() на програмата се пази в стека докато програмата завърши изпълнението на този метод, т.е. докато не завърши.

Пример 2: Куп с чинии

Пример 3: Куп с книги

Защото: Стекът има поведение последен влязъл пръв излязъл.


-----------------------------------------------------------------------------

Имате следния пример:

Трябва да намерите елемент в масив по даден ключ. Посочете сложността на алгоритъма в най-лошия, среден и най-добър случай:

Най-лош случай: [O(N)]

Среден случай: [O(N)]

Най-добър случай: [O(1)]


-----------------------------------------------------------------------------

Имате даден следният програмен фрагмент. Свържете правилно липсващите части от кода.  

          int low = 0;
            int high = sortedArray.Length - 1;
            while (sortedArray[[low]] <= key && sortedArray[[high]] >= key)
            {
                int mid = low + ((key - sortedArray[low]) * (high - low))
                  / (sortedArray[high] - sortedArray[low]);
                if ([sortedArray[mid] < key])
                    low = mid + 1;
                else if ([sortedArray[mid] > key])
                    high = mid - 1;
                else
                    return mid;
            }
            if ([sortedArray[low] == key]) return low;
            else return -1;


-----------------------------------------------------------------------------

Имате следния програмен фрагмент:

private static int FindMaxElement(int[] array)
{
int max
for (int i
{
int.MinValue;
i < array.length; i++)
if (array[i] > max)
{
}
max = array[il;
}
return max;

Каква ще бъде сложността на алгоритъма и обяснете защо?

Ако имаме единичен цикъл от 1 до N, сложността му е линейна – O(N):


-----------------------------------------------------------------------------

public class CircularQueue<T>
{
}
private const int DefaultCapacity = 4;
public int Count { get; private set; } public CircularQueue(int capacity
public void Enqueue(T element) { ... }
public T Dequeue() { ... }
public T[] ToArray() { }
DefaultCapacity) { }

На картинката е показана част от имплементацията на линейната структура от данни опашка. Посочете коя имплементация е използвана:

Изберете едно
a. Имплементация на опашка базирана на възли (nodes)
b. Дървовидна имплементация на опашка
c. Статична имплементация на опашка<<<<<<<<<<<<<<<<<<
d. Динамична имплементация на опашка

-----------------------------------------------------------------------------

Разработвате ново приложение за оптимизиране на процесите в работата на призводствено предприятие. Трябва да приложите структура от данни, която да работи като „буфер“ срещу надхвърляне на капацитета. 
Когато сме в рамките на призводствения капацитет, артикулите в буфера трябва да се обработят в реда, в който се добавят. 
Обяснете коя структура от данни трябва да използвате защо бихте използвали точно нея, за да приложите такъв буфер?

В опашката, артикулите се обработват в реда, в който са добавени. В частност, артикулите се добавят в края на опашката и се премахват от началото. Това е общоизвестно като first-in, first-out (FIFO) обработване.

-----------------------------------------------------------------------------

Ако имате следната последователност от числа: "15, 85, 34, 12, 0, -9, 14, 63, 7, 32" и трябва да напишете алгоритъм, който да намери елемент от този списък, например числото 34. 

Като използвате алгоритъма за линейно търсене обяснете последователността от стъпки, които трябва да се изпълнят за да намерите търсеното число. 

А какво ще се случи, ако търсеното число не е в списъка?

Линейното търсене е прост подход за намиране на елемент в списък.
Започваме от най-левия елемент на масива и едно по едно сравняваме търсеното число (х) с всеки елемент на масива.
Ако x съвпада с елемент от масива, връщаме индекса, в случая числото 34 е на индекс 2 и алгоритъма трябва да върне числото 2 като резултат.
Ако x не съвпада с нито един от елементите, връщаме -1.

-----------------------------------------------------------------------------

Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез вмъкване.

public static void InsertionSort(List<int> list)
        {
            for (int i = 1; i < list.Count; ++i)
            {
                int key = list[i];
                int j = i - 1;

                // Move elements of arr[0..i-1], 
                // that are greater than key, 
                // to one position ahead of 
                // their current position 
                while (j >= 0 && list[j] > key)
                {
                    list[j + 1] = list[j];
                    j = j - 1;
                }
                list[j + 1] = key;
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }


-----------------------------------------------------------------------------\

Посочете за алгоритми с каква сложност се отнася следното твърдение:

Алгоритми с [константна, логаритмична и линейна] сложност са толкова бързи, че не можем да усетим забавяне, дори при относително голям размер на входните данни.


-----------------------------------------------------------------------------\

Имате даден следният псевдо код на алгоритъм за сортиране. Посочете кой алгоритъм за сортиране е използван:


repeat (numOfElements - 1) times
set the first unsorted element as the minimum
for each of the unsorted elements
if element < currentMinimum
set element as new minimum
swap minimum with first unsorted position

Това е псевдо код за имплементация на алгоритъм за сортиране чрез [пряка селекция]

-----------------------------------------------------------------------------\

Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез пряка селекция. 

public static void SelectionSort(List<int> list)
        {
            for (int index = 0; index < list.Count; index++)
            {
                int min = index;
                for (int current = index + 1; current < list.Count; current++)
                {
                    if(list[current] < list[min])
                    {
                        min = current;
                    }
                }

                Swap(list, index, min);
            }
            
        }

private static void Swap(List<int> list, int index, int min)

        {

            int temp = list[index];

            list[index] = list[min];

            list[min] = temp;

        }

-----------------------------------------------------------------------------\

Имате следния програмен фрагмент:

long Sum(int n)
{
long sum = 0;
for (int a = 1; a < n; a++)
{
for (int b = 1; b < n; b++)
{
for (int c = 1; c < n; c++)
{
sum += a
b
* c;l
}
}

Каква ще бъде сложността на алгоритъма и обяснете защо?


Ако имаме три вложени цикъла от 1 до N, сложността им е кубична – O(N3).

-----------------------------------------------------------------------------\









































