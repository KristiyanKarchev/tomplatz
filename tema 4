--------------------------------------------------------------------------------------------------------------


Открийте липсващите думи в текста:

Възможността референция към [базов клас ] да сочи обект както от базовия, така и обект от някой от производните класове е в основата на реализацията на [полиморфизма ] в езика C#.

Кои от следните примери потвърждават това правило, ако имате следната йерархия class Cat : class Animal ?

Cat cat  = new Animal(); [не]

Animal animal = new Animal(); [да]

Animal animal = new Cat(); [да]


--------------------------------------------------------------------------------------------------------------

Абстракцията е основен принцип от обектно-ориентираното програмиране.

Абстракцията означава да работим с нещо, което знаем как да използваме, но не знаем как работи вътрешно.

Абстракцията е действие, при което игнорираме всички детайли, които не ни интересуват от даден обект, и разглеждаме само детайлите, които имат значение за проблема, който решаваме.

Абстракцията ни позволява да пишем код, който работи с абстрактни струк­тури от данни (например списък, речник, множество и други). Имайки абстрактния тип данни, ние можем да работим с него през неговия интер­фейс, без да се интересуваме от имплементацията му.

Има два начина за постигане на абстракция:
Интерфейси (100% абстракция)
Абстрактен клас (0% - 100% абстракция)


--------------------------------------------------------------------------------------------------------------

Открийте разликите между клас и интерфейс. Кои от изброените твърдения се отнасят за класовете в C#, кои за интерфейсите?

Има както дефиниция, така и реализация. [Клас]

Има само дефиниция. [Интерфейс]

Не може да бъде инстанциран. [Интерфейс]

Може да бъде инстанциран. [Клас]

Може да съдържа членове, методи, заедно с дефиниция и реализация. [Клас]

Набор от дефиниции, които трябва да се приложат. [Интерфейс]

--------------------------------------------------------------------------------------------------------------

Имате даден следния код:

Console.WriteLine("Add two integer Number = " + r);

Опишете кой от видовете полиморфизъм е използван в примера по-горе.

Полиморфизъм по време на компилиране

--------------------------------------------------------------------------------------------------------------

Посочете кое от изброените твърдение е вярно за класовете в C#.

Изберете едно или повече:
a. Той е референтен тип и включва само абстрактни членове като събития, методи и свойства.
b. Описва състоянието и поведението на обектите<<<<<<<<<<<<<<<<<<<<<<<
c. Поддържа множествено наследяване.
d. Можем да създаваме инстанции.<<<<<<<<<<<<<<<<<<<<<<<<<<<<

--------------------------------------------------------------------------------------------------------------

Посочете кое от изброените е дефиниция на метод, който може да бъде презаписан в клас наследник.

Изберете едно
a. Всеки метод може да бъде презаписан.
b. Статичен метод.
c. Виртуален метод.<<<<<<<<<<<<<<<<<<<<<<<<
d. Нито едно от изброените.

--------------------------------------------------------------------------------------------------------------

Имате даден следния код:

Console.WriteLine("This is Show from ClassB");

Опишете кой от видовете полиморфизъм е използван в примера по-горе.

Правилният отговор е: Полиморфизъм по време на изпълнение.

--------------------------------------------------------------------------------------------------------------

Дефинирайте термина полиморфизъм в обектно-ориентираното програмиране, като поставите липсващите думи в текста.

Терминът полиморфизъм в обектно-ориентираното програмиране определя, че [едни и същи (еднотипни)] действия се реализират по [различен начин] в зависимост от обектите, върху които се прилагат. 
Такива действия се наричат [полиморфични].
За да се реализира [полиморфно действие], класовете на обектите, върху които се прилага това действие, трябва да имат [общ корен] т.е. да бъдат производни на [един и същи клас].

--------------------------------------------------------------------------------------------------------------

 Обяснете основните разлики между презареждане и презаписване на методи.

Методи с едно и също име, но различни сигнатури. [Презареждане на методи]
Може да се случи в същия клас или в негов подклас. [Презареждане на методи]
Може да се случи в подкласовете. [Презаписване на методи]
Трябва да има същия тип на връщана стойност. [Презаписване на методи]
При компилиране, според подадените параметри компилатора определя кой метод точно ще изпълни. [Презареждане на методи]
Модификатора за достъп не може да бъде по-ограничаващ. [Презаписване на методи]


--------------------------------------------------------------------------------------------------------------

Sвържете кои от характеристиките се отнасят за абстрактните класове, кои за интерфейсите.

Може да притежава полета и константи. [Абстрактни класове]

Е по-добър избор, ако множество имплементации споделят само сигнатурата на методите и нищо друго. [Интерфейси]

Не поддържа полета. [Интерфейси]

Е по-добър избор, ако множество имплементации са от сходен вид и имат общо поведение или статут. [Абстрактни класове]

Ако добавим нов метод, то имаме опцията да създадем имплементация по подразбиране и така съществуващият код ще може да работи коректно. [Абстрактни класове]

Ако добавим нов метод, то трябва да проследим всичките му имплементации и да дефинираме имплементация за новия метод. [Интерфейси]

--------------------------------------------------------------------------------------------------------------

Дайте пример чрез код на C# за това как и къде бихте използвали презареждане на методи. 

 class MathOperations
    {
        public int Add(int a, int b)
        {
            return a + b;   
        }
        public int Add(int a, int b,int c)
        {
            return a + b + c;
        }
    }

--------------------------------------------------------------------------------------------------------------

Посочете кое от изброените твърдение е вярно за интерфейсите в C#.

Изберете едно или повече:
a. Предоставя договор, определящ как да се създаде обект, без да се интересува от спецификата на това как обекта ще прави нещата.<<<<<<<<<<<<<<<<<<<<<<<<
b. Това са парчета код,които отговарят за изпълнението на дадено действие, което спомага за решаване на определен проблем. 
c. Това е референтен тип и включва само абстрактни членове като събития, методи, свойства и т.н. и няма реализации за нито един от своите членове.<<<<<<<<<<<<<<<<<<<<<<<
d. Това е шаблон, който описва видовете състояние и поведение, които обектите от неговия тип поддържат.


--------------------------------------------------------------------------------------------------------------


Имате следния код:

public List<T> CreateList<T>(T item, int count)//2т
        {
            List<T> list = new List<T>();//2т
            for (int i = 0; i < count; i++)
            {
                list.Add(item);
            }
            return list;//2т
        }

 Модифицирайте кода,така че методът да работи с всякакъв тип данни.
 
 
--------------------------------------------------------------------------------------------------------------

Дайте пример за абстракция. Напишете примерен код, който:

Има класовете BaseEmployee, FullTimeEmployee и ContractEmployee.

Условието на задачата е всички работници да имат име, както и  метод CalculateSalary(int workingHours) - който ще изчислява заплатата за работника, като се приема параметър – брой изработени часове. 

Заплатата на FullTimeEmployee се изчислява по формулата: 250 + workingHours*10.80.

А заплатата на ContractEmployee по формулата: 250 + workingHours*20.

Спазвайте принципа за абстракция в обектно-ориентираното програмиране. 



abstract class BaseEmployee
    {
        public string Name { get; set; }
        public abstract double CalculateSalary(int workingHours);
    }

    class FullTimeEmployee : BaseEmployee
    {
        public override double CalculateSalary(int workingHours)
        {
            return 250 + workingHours * 10.80;
        }
    }

    class ContractEmployee : BaseEmployee
    {
        public override double CalculateSalary(int workingHours)
        {
            return 250 + workingHours * 20;
        }
    }

--------------------------------------------------------------------------------------------------------------

Посочете в кой от случаите бихте използвали шаблонни класове?

Изберете едно
a. Когато се налага да преизползваме базовите функционалности на родителския клас и/или трябва да презапишем поведението на наследниците.
b. Когато се налага да се създават класове, които използват еднотипни обекти и с различна функционалност.
c. Когато се налага да третираме обектите от наследен клас като обекти от негов базов клас.
d. Когато се налага да се създават класове, които са сходни по функционалност, а се различават само по типа на обектите, с които работят.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

--------------------------------------------------------------------------------------------------------------


Имате абстрактен клас и обикновен клас. Открийте и свържете коя от характеристиките се отнася за абстрактния клас и коя за не абстрактен клас.



Не можем да създаваме инстанции. [Абстрактен клас ]

Може да има само абстрактни членове на класа. [За нито един от двата]

Могат да дефинират методи без тяло (без имплементация). [Абстрактен клас ]

Можем да създаваме инстанции. [Обикновен клас]

Може да има само не-абстрактни членове на класа. [Обикновен клас]

Не могат да дефинират методи без тяло (имплементация). [Обикновен клас]

Съдържа ключовата дума abstract пред ключовата дума class. [Абстрактен клас ]

Може да има абстрактни и не-абстрактни членове на класа. [Абстрактен клас ]

Не съдържа ключовата дума abstract пред ключовата дума class. [Обикновен клас]

--------------------------------------------------------------------------------------------------------------

Дайте пример за шаблонен клас, който да се казва Кутия и тази кутия да може да съхранява всичко. 
В този клас създайте и един метод, който да проверява и връща като резултат дали даден елемент се съдържа в тази кутия.


class Box<T>
    {
        private List<T> items;

        public Box()
        {
            items = new List<T>();  
        }

        public bool Contains(T item)
        {
            return this.items.Contains(item);
        }
}

--------------------------------------------------------------------------------------------------------------


Посочете по какъв начин бихте декларирали шаблонен клас в C#.

Изберете едно
a. class ClassName(T)
{ 

}
b. class ClassName"T"
{ 

}
c. class ClassName{T}
{ 

}
d. class ClassName<T> <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
{ 

}

--------------------------------------------------------------------------------------------------------------

Дефинирайте понятието наследяване от обектно-ориентираното програмиране като попълните липсващите думи в текста.

Наследяването е [основен принцип] от обектно-ориентираното програми­ране. То позволява на един клас да "наследява" [поведение и характе­ристики] от друг, по-общ клас. 

В .NET и други модерни езици за програмиране един клас може да наследи [само един друг клас].


Класът, който [дава ] своите членове на [дъщерния] си клас се нарича [базов] клас. А класът, който [получава] членове от [своя базов клас] - [подклас].

--------------------------------------------------------------------------------------------------------------

Имате следния код:

public class Scale<T> where T : IComparable<T>//2т
    {
        private T left; //1т
        private T right; //1т

        public Scale(T left, T right)//2т
        {
            this.left = left;
            this.right = right;
        }
        public T GetHavier()
        {
            if (left.CompareTo(right) > 0)
            { return left; }
            else if (left.CompareTo(right) < 0)
            { return right; }
            return default(T);
        }
    }

Модифицирайте кода,така че Везната да може да сравнява всякакви типове данни. Също така трябва да ограничите Везната, че елементите, които ще  сравнява ще бъдат само сравними типове. 

--------------------------------------------------------------------------------------------------------------

Посочете какви са приликите и разликите между полиморфизъм и абстракция в обектно-ориентираното програмиране като поставите липсващите думи в текста.

Полиморфизмът може много да напомня на абстракцията, но в програми­рането се свързва най-вече с [пренаписването (override) ] на методи в [нас­ледените класове] с цел [промяна на оригиналното им поведение], 
насле­дено от базовия клас. Абстракцията се свързва със [създаването на интерфейс на компонент] или функционалност.

--------------------------------------------------------------------------------------------------------------

Свържете кои от характеристиките се отнасят за абстрактните класове, кои за интерфейсите.

Може да наследи само един абстрактен клас. [Абстракция]

Могат да предоставят целия код и/или само детайлите, които трябва да се презапишат. [Абстракция]

Може да имплементира няколко интерфейса. [И за двете ]

Може да съдържа модификатори за достъп. [Абстракция]

Не може да предоставя никакъв код, предоставя само описание. [Интерфейси]                        

Нямат модификатори за достъп. Всичко е публично по подразбиране. [Интерфейси]


--------------------------------------------------------------------------------------------------------------


Дайте пример чрез код на C# за това как и къде бихте използвали презаписване на методи. 

Например имате класовете Animal и Dog. Имате и един единствен метод MakeTrick(), който трябва да отпечатва на конзолата за всички животни, че по подразбиране не могат да правят никакъв трик ("No trick!"). Само и единствено кучето умее трика да подава лапа ("Give a paw!"). 

Реализирайте примера чрез код на C#.

 class Animal
{
        public virtual void MakeTrick()
        {
            Console.WriteLine("No trick...");
        }
}
class Dog : Animal
{
        public override void MakeTrick()
        {
            Console.WriteLine("Give a paw...");
        }
}

--------------------------------------------------------------------------------------------------------------

Открийте липсващите думи и свържете правилно изреченията:

При дефиниране на обекти от базови и производни класове е възможно на обект от [базов клас] да се присвои обект от [производен клас] т.е. обект от [производен клас] 
може да служи за инициализация на обект (референция) от [базов клас].

Възможно е също да се осъществи обръщение към обект чрез променлива от друг тип, ако използвания тип е клас, намиращ се на [по‑високо ] ниво в йерархията на наследяване. Обратното [не е възможно].

--------------------------------------------------------------------------------------------------------------

Имате зададена следната схема:

Animal
-string name
-string favouriteFood

Методът ExplainMyself ще бъде презаписан или презареден? 

Запишете отговора си в полето и обяснете защо?

Методът ще бъде презаписан, защото се използва в подкласовете и има една и съща сигнатура.

--------------------------------------------------------------------------------------------------------------

Посочете по какъв начин в C# можем да укажем, че искаме да подменим (препокрием) виртуален метод.
Изберете едно
a. Чрез ключовата дума overload поставена на методи в базовия клас.
b. Чрез ключовата дума overload поставена на методи в наследниците.
c. Чрез ключовата дума override поставена на методи в наследниците.<<<<<<<<<<<<<<<<<<<<<<<<<<<<
d. Чрез ключовата дума override поставена на методи в базовия клас.

--------------------------------------------------------------------------------------------------------------

Свържете кои от характеристиките се отнасят за абстракцията, кои за енкапсулацията.


Получава се чрез модификаторите за достъп (private, public, protected, internal) [Енкапсулация]

Постига се чрез интерфейси и абстрактни класове. [Абстракция]

Процес на скриване на подробностите на имплементацията и показване само на функционалностите към потребителя. [Абстракция]

Използва се, за  да скрива кода и информацията в един компонент, за да я защити от външния свят. [Енкапсулация]

--------------------------------------------------------------------------------------------------------------

Посочете видовете полиморфизъм в .NET.
Изберете едно или повече:
a. Нито едно от изброените. 
b. Полиморфизъм по време на компилиране.<<<<<<<<<<<<<<<<<<<<
c. Полиморфизъм по време на създаване. 
d. Полиморфизъм по време на изпълнение. <<<<<<<<<<<<<<<<<<<<<<<<<

--------------------------------------------------------------------------------------------------------------

Посочете видовете полиморфизъм в .NET.
Изберете едно или повече:
a. Статичен.<<<<<<<<<<<<<<<
b. Динамичен.<<<<<<<<<<<<<<<<
c. Виртуален.
d. Нито едно от изброените. 

--------------------------------------------------------------------------------------------------------------

Дайте пример за шаблонен клас, който да се казва Кутия и тази кутия да може да съхранява всичко. В този клас създайте и един метод, който да добавя елемент в края на редицата.


class Box<T>
    {
        private List<T> items;

        public Box()
        {
            items = new List<T>();  
        }
        public void Add(T item)
        {
            this.items.Add(item);
        }
    }
    
    
--------------------------------------------------------------------------------------------------------------

Дефинирайте понятието полиморфизъм в обектно-ориентираното програмиране като попълните липсващите думи в текста.

Полиморфизмът в обектно-ориентираното програмиране представлява свойството на обектите от един и същи [тип] да имат един и същи [интерфейс], 
но с [различна реализация] на този [интерфейс]. „Един [интерфейс], [множество от различни реализации]“. Чрез полиморфизма се постига по-голяма [абстракция ] и по-лесно [повторно използване] на кода.

--------------------------------------------------------------------------------------------------------------

Избройте четирите основни принципа на обектно-ориентираното програмиране.


Правилният отговор е: капсулация, наследяване, абстракция, полиморфизъм

--------------------------------------------------------------------------------------------------------------

Посочете кое е другото название, с което наричаме шаблонните класове в C#.

Правилният отговор е: Generics

--------------------------------------------------------------------------------------------------------------

Посочете по какъв начин указваме на даден метод от базовия клас, че искаме да презапишем неговото поведение.

Изберете едно
a. Чрез ключовата дума overwrite.
b. Чрез ключовата дума override.
c. Чрез ключовата дума virtual.<<<<<<<<<<<<<<<<<<<<<
d. Чрез ключовата дума static.

--------------------------------------------------------------------------------------------------------------

Създайте следната йерархия от класове и интерфейси.

За ваше удобство ще ви бъде предоставен скелет на задачата, който обаче е непълен/неработещ/некоректен. Предоставеният скелет трябва да се приведе в работещ вид.

Интерфейс IMakeNoise code debug animals

using System;
using System.Collections.Generic;
using System.Linq;

interface IMakeNoise
{
    string MakeNoise();
}

interface IMakeTrick
{
    string MakeTrick();
}

interface IAnimal
{
    string Type { get; }
    string Name { get; }
    void Perform();
}

abstract class Animal : IAnimal
{
    private string name;

    protected Animal(string name)
    {
        Name = name;
    }

    public string Name
    {
        get { return name; }
        private set
        {
            if (string.IsNullOrEmpty(value) || string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Name can't be null or empty!");
            }
            name = value;
        }
    }

    public abstract string Type { get; }

    public void Perform()
    {
        Console.WriteLine($">>> {MakeNoise()}");
        Console.WriteLine($">>> {MakeTrick()}");
    }

    public override string ToString()
    {
        return $"{Type} {Name}";
    }
}

class Cat : Animal, IMakeNoise, IMakeTrick
{
    public Cat(string name) : base(name)
    {
    }

    public override string Type => "Cat";

    public string MakeNoise()
    {
        return "Meow!";
    }

    public string MakeTrick()
    {
        return "No trick for you! I'm too lazy!";
    }
}

class Dog : Animal, IMakeNoise, IMakeTrick
{
    public Dog(string name) : base(name)
    {
    }

    public override string Type => "Dog";

    public string MakeNoise()
    {
        return "Woof!";
    }

    public string MakeTrick()
    {
        return "Hold my paw, human!";
    }
}

class Trainer
{
    private IAnimal entity;
    private string name;

    public Trainer(string name, IAnimal entity)
    {
        Name = name;
        Entity = entity;
    }

    public string Name
    {
        private set
        {
            if (string.IsNullOrEmpty(value) || string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Name can't be null or empty!");
            }
            name = value;
        }
        get { return name; }
    }

    public IAnimal Entity
    {
        private set
        {
            entity = value;
        }
        get { return entity; }
    }

    public void Work(IAnimal entity)
    {
        this.Entity = entity;
        Console.WriteLine($"Trainer {this.Name} works with {Entity}!");
    }

    public void Make()
    {
        this.Entity.Perform();
    }
}

class Program
{
    static void Main(string[] args)
    {
        List<IAnimal> animals = new List<IAnimal>();

        int n = int.Parse(Console.ReadLine());

        for (int i = 0; i < n; i++)
        {
            string[] line = Console.ReadLine().Split();
            IAnimal animal = CreateAnimal(line);
            animals.Add(animal);
        }

        string trainerName = Console.ReadLine();
        Trainer trainer = null;

        string name = Console.ReadLine();

        while (name != "End")
        {
            IAnimal current = animals.FirstOrDefault(a => a.Name.Equals(name));

            if (current == null)
            {
                Console.WriteLine("No such name in the Database!");
            }
            else
            {
                if (trainer == null)
                {
                    trainer = new Trainer(trainerName, current);
                }
                trainer.Work(current);
                trainer.Make();
            }

            name = Console.ReadLine();
        }
    }

    private static IAnimal CreateAnimal(string[] line)
    {
        IAnimal animal = null;

        switch (line[0])
        {
            case "Cat":
                animal = new Cat(line[1]);
                break;
            case "Dog":
                animal = new Dog(line[1]);
                break;
        }

        return animal;
    }
}

--------------------------------------------------------------------------------------------------------------

По време на теоретичния изпит се предоставя непълен/неработещ/некоректен програмен фрагмент. Предоставеният фрагмент да се приведе в работещ вид.

Предоставеният фрагмент е непълен/некоректен.

Вашата задача е да приведе предоставеният програмен код в работещ вид.


По време на теоретичния изпит се предоставя непълен/неработещ/некоректен програмен фрагмент. Предоставеният фрагмент да се приведе в работещ вид.

Тоталитрано дистопично общество

Бъдещето е! Вие сте владетел на тоталитрано дистопично общество населено с граждани и бунтовници!

using System;
using System.Collections.Generic;
using System.Linq;

interface IBuyer
{
    void BuyFood();
    int Food { get; }
}

interface IIdentifiable
{
    string Id { get; }
}

interface IPersonable
{
    string Name { get; }
    int Age { get; }
}

class Community : IIdentifiable, IPersonable, IBuyer
{
    private string id;
    private string name;
    private int age;
    private int food;

    public Community(string id, string name, int age)
    {
        Id = id;
        Name = name;
        Age = age;
        Food = 0;
    }

    public string Id
    {
        get { return id; }
        set { id = value; }
    }

    public string Name
    {
        get { return name; }
    }

    public int Age
    {
        get { return age; }
        set { age = value; }
    }

    public int Food
    {
        get { return food; }
        protected set { food = value; }
    }

    public virtual void BuyFood()
    {
        Food += 10;
    }

    public override string ToString()
    {
        return $"ID:{Id} {GetType().Name} Name: {Name} Age {Age} Food: {Food}";
    }
}

class Citizen : Community
{
    private string birthdate;

    public Citizen(string id, string name, int age, string birthdate)
        : base(id, name, age)
    {
        Birthdate = birthdate;
    }

    public string Birthdate
    {
        get { return birthdate; }
        set { birthdate = value; }
    }

    public override void BuyFood()
    {
        Food += 10;
    }

    public override string ToString()
    {
        return base.ToString() + $" Birthdate {Birthdate}";
    }
}

class Rebel : Community
{
    private string group;

    public Rebel(string id, string name, int age, string group)
        : base(id, name, age)
    {
        Group = group;
    }

    public string Group
    {
        get { return group; }
        set { group = value; }
    }

    public override void BuyFood()
    {
        Food += 5;
    }

    public override string ToString()
    {
        return base.ToString() + $" Group {Group}";
    }
}

class Program
{
    static void Main(string[] args)
    {
        int n = int.Parse(Console.ReadLine());
        Dictionary<string, Community> community = new Dictionary<string, Community>();

        for (int i = 0; i < n; i++)
        {
            string[] input = Console.ReadLine().Split();

            if (input[0].StartsWith("R"))
            {
                string id = input[0];
                string name = input[1];
                int age = int.Parse(input[2]);
                string group = input[3];

                community[id] = new Rebel(id, name, age, group);
            }
            else if (input[0].StartsWith("C"))
            {
                string id = input[0];
                string name = input[1];
                int age = int.Parse(input[2]);
                string birthdate = input[3];

                community[id] = new Citizen(id, name, age, birthdate);
            }
        }

        string id = Console.ReadLine();

        while (id != "End")
        {
            if (community.ContainsKey(id))
            {
                community[id].BuyFood();
            }
            else
            {
                Console.WriteLine($"Entity with {id} does not exist!");
            }

            id = Console.ReadLine();
        }

        int totalFood = community.Sum(c => c.Value.Food);

        foreach (var person in community.Values)
        {
            Console.WriteLine(person);
        }

        Console.WriteLine($"TotalFood: {totalFood}");
    }
}

--------------------------------------------------------------------------------------------------------------

Дайте пример за наследяване в C#. 

Имате клас Animal с метод Eat(), който отпечатва "Eating...". Имате Котка и Куче, които трябва да наследяват от Animal. 
Те обаче трябва да могат да издават звук. Котката трябва да казва "Meow", а Кучето - "Bark". 
За тази цел създайте методи със съответните имена, котио извеждат на екрана звуците на всяко животно. Направете така че да не бъде възможно да се създаде обект от клас Animal.

Реализирайте го чрез програмен код на C#.

using System;

class Animal
{
    public void Eat()
    {
        Console.WriteLine("Eating...");
    }
}

class Cat : Animal
{
    public void Meow()
    {
        Console.WriteLine("Meow");
    }
}

class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine("Bark");
    }
}

--------------------------------------------------------------------------------------------------------------

Дайте пример за шаблонен клас, който да се казва Кутия и тази кутия да може да съхранява всичко. 
В този клас създайте и един метод, който да премахва първия елемент от кутията и да връща като резултат неговата стойност.

using System;
using System.Collections.Generic;

class Box<T>
{
    private List<T> items;

    public Box()
    {
        items = new List<T>();
    }

    public void Add(T item)
    {
        items.Add(item);
    }

    public T RemoveFirst()
    {
        if (items.Count == 0)
        {
            throw new InvalidOperationException("The box is empty.");
        }

        T firstItem = items[0];
        items.RemoveAt(0);
        return firstItem;
    }
}

--------------------------------------------------------------------------------------------------------------

Имате следния пример: 

клас Circle е производен на абстрактният клас Figure. 

Демонстрирайте начините, по които е възможно да се декларира референция на някой от класовете, която да сочи обект от клас Circle:

Ето няколко начина, по които може да се декларира референция, която да сочи обект от клас Circle, който е производен на абстрактния клас Figure:

Чрез деклариране на променлива от типа на базовия клас и присвояване на обект от производния клас: Figure circle1 = new Circle();

Чрез деклариране на променлива от типа на производния клас: Circle circle2 = new Circle();

 --------------------------------------------------------------------------------------------------------------
 
 

























































































































































































































































































































































