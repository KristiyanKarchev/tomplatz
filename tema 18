--------------------------------------------------------------------

По време на теоретичния изпит се предоставя непълен/неработещ/некоректен програмен фрагмент. Предоставеният фрагмент да се приведе в работещ вид.

Условие:

Да се напише програма, която получава цяло число n. След това програмата да генерира масива с n на брой елементи от случайни числа в интервала [-100; 100]. Програмата трябва да разполага с две нишки, които намират и отпечатват съответно сумата и броя на нулите от елементите в масива.


Предоставен фрагмент:

using System;

using System.Collections.Generic;

using System.Linq;

using System.Threading;


namespace ExampleThread1

{

class Program

[{]

[static] void FindSum(int[] arr)

{

[int sum = 0;]

[for (int i = 0; i < arr.Length; i++)]

{

[sum += arr[i];]

}



Console.WriteLine($"Sum: {sum}");

}

static void FindZero([int[] arr])

{

[int zeroes = 0;]

for (int i = 0; i < arr.Length; i++)

{

if (arr[i] == 0)

{

[max = arr[i];]

}

}

Console.WriteLine($"Zeroes: {zeroes}");

}

static void Main(string[] args)

{

int n = int.Parse(Console.ReadLine());

int[] arr = new int[n];

Random r = new Random();

for (int i = 0; i < n; i++)

{

arr[i] = r.Next(-100, 100);

}


[Thread t1 = new Thread(() => FindSum(arr));]

Thread t2 = new Thread(() => FindZero(arr));

t1.Start();

t2.Start();

[}]

}

}

--------------------------------------------------------------------

По време на теоретичния изпит се предоставя непълен/неработещ/некоректен програмен фрагмент. Предоставеният фрагмент да се приведе в работещ вид.


Условие:

Да се напише програма, която получава цяло число n. След това програмата да генерира масива с n на брой елементи от случайни числа в интервала [-100; 100]. Програмата трябва да разполага с две нишки, които намират и отпечатват съответно броя на четните и броя на нечетните елементите в масива.


Предоставен фрагмент:

using System;

using System.Collections.Generic;

using System.Linq;

using System.Threading;


namespace ExampleThread1

{

class Program

[{]

[static] void FindEven(int[] arr)

{

[int countEven = 0;]

[for (int i = 0; i < arr.Length; i++)]

{

[if(arr[i] % 2 == 0) { countEven++; }]

}



Console.WriteLine($"Even: {countEven}");

}

static void FindOdd([int[] arr])

{

[int countOdd = 0;]

for (int i = 0; i < arr.Length; i++)

{

if (arr[i] % 2 != 0)

{

[countOdd++;]

}

}

Console.WriteLine($"Odd: {countOdd}");

}

static void Main(string[] args)

{

int n = int.Parse(Console.ReadLine());

int[] arr = new int[n];

Random r = new Random();

for (int i = 0; i < n; i++)

{

arr[i] = r.Next(-100, 100);

}


[Thread t1 = new Thread(() => FindEven(arr));]

Thread t2 = new Thread(() => FindOdd(arr));

t1.Start();

t2.Start();

[}]

}

}

--------------------------------------------------------------------

По време на теоретичния изпит се предоставя непълен/неработещ/некоректен програмен фрагмент. Предоставеният фрагмент да се приведе в работещ вид.

Условие:

Да се напише програма, която получава цяло число n. След това програмата да генерира масива с n на брой елементи от случайни числа в интервала [-100; 100]. Програмата трябва да разполага с две нишки, които намират и отпечатват съответно минимума и максимума от елементите в масива.


Предоставен фрагмент:

using System;

using System.Collections.Generic;

using System.Linq;

using System.Threading;


namespace ExampleThread1

{

class Program

[{]

[static] void FindMin(int[] arr)

{

[int min = arr[0];]

[for (int i = 0; i < arr.Length; i++)]

{

if ([arr[i] < min])

{

min = [arr[i]];

}

}

Console.WriteLine($"Minimum: {min}");

}

static void FindMax([int[] arr])

{

int max = arr[0];

for (int i = 0; i < arr.Length; i++)

{

if (arr[i] > max)

{

[max = arr[i];]

}

}

Console.WriteLine($"Maximum: {max}");

}

static void Main(string[] args)

{

int n = int.Parse(Console.ReadLine());

int[] arr = new int[n];

Random r = new Random();

for (int i = 0; i < n; i++)

{

arr[i] = r.Next(-100, 100);

}


[Thread t1 = new Thread(() => FindMin(arr));]

Thread t2 = new Thread(() => FindMax(arr));

t1.Start();

t2.Start();

[}]

}

}

--------------------------------------------------------------------

Дефиницията „Абстракция на програма в режим на изпълнение” е на понятието:


Изберете едно
a.
процес<<<<<<<<<<<<<<<<<<<

b.
асинхронност

c.
конкурентност

d.
нишка

--------------------------------------------------------------------

Кой е проблемът, който отговаря на посоченото описание?
Това е самоизключващо се блокиране. Такова състояние може да възникне, ако нишка А засече, 
че нишка Б се опитва да заеме ресурс и се опита да го освободи. От своя страна при получаване на ресурса нишка Б също се опитва да го освободи отново за нишка А. Това може да продължи до безкрайност.

Правилният отговор е: Жива хватка (livelock)


--------------------------------------------------------------------

Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. Включете целия необходим код в отговора, в това число class Program и Main метод.


static void Count(int n) {

    for(int i = n; i >= 0; i--) {

        Console.WriteLine(i);

    }

}

ВЕРНИЯ ОТГОВОР Е:

using System;
using System.Threading;

class Program
{
    static void Main()
    {
        // Създаване на нишка и подаване на аргумент
        Thread thread = new Thread(() => Count(10));
        
        // Стартиране на нишката
        thread.Start();

        // Изчакване нишката да завърши
        thread.Join();

        Console.WriteLine("Главният метод завърши.");
    }

    static void Count(int n)
    {
        for (int i = n; i >= 0; i--)
        {
            Console.WriteLine(i);
        }
    }
}

--------------------------------------------------------------------

Кое от следните НЕ е метод на Thread обекта.


Изберете едно
a.
Stop<<<<<<<<<<<<<<<<<<<<<<<<

b. Sleep
c.
Start

d.
Join

--------------------------------------------------------------------

Дайте пример за поне два вида конкурентност.

Ето два примера за различни видове конкурентност:

Многонишкова конкурентност (Multithreading) - В този вид конкурентност, програмата изпълнява няколко нишки паралелно, като всеки нишков процес се изпълнява независимо от другите

Конкурентност на база събития (Event-based concurrency) - Това е вид конкурентност, при който програмата реагира на външни събития или известия

--------------------------------------------------------------------

Дайте пример за ситуация, в която възниква проблем „гладуване“ (starvation)?

Един пример за ситуация, в която възниква проблем на "гладуване" (starvation), 
е когато няколко нишки конкурират за достъп до ресурс и една или повече от тях не получават необходимия достъп за изпълнение на своята задача поради постоянното предпочитане на други нишки.


--------------------------------------------------------------------

Кое от следните НЕ е свойство на нишка?


Изберете едно
a.
IsThreadPoolThread

b.
Value<<<<<<<<<<<<<<<<<<<<<<<<<<<<

c.
IsBackgroundThread

d.
ThreadState


--------------------------------------------------------------------


Свойството ThreadState на нишка показва:


Изберете едно
a.
дали работи на преден или заден план

b.
номерът на нишката

c.
състоянието на нишката<<<<<<<<<<<<<<<<<<<<<<<<<<<

d.
дали е част от пула с нишки


--------------------------------------------------------------------

Свойството IsBackgroundThread на нишка показва:


Изберете едно
a.
номерът на нишката

b.
дали работи на преден или заден план<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

c.
състоянието на нишката

d.
дали е част от пула с нишки

--------------------------------------------------------------------

Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. Включете целия необходим код в отговора, в това число class Program и Main метод.


static void PrintTriangle(int n) {

    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= i; j++)
        {
           Console.Write($"{j} ");
        }
        Console.WriteLine();
    }

}

ВЕРНИЯ ОТГОВОР Е:

using System;
using System.Threading;

class Program
{
    static void Main()
    {
        // Създаване на нова нишка
        Thread thread = new Thread(() => PrintTriangle(5));

        // Стартиране на нишката
        thread.Start();

        // Изчакване на завършването на нишката
        thread.Join();

        Console.WriteLine("Главната нишка завърши.");
    }

    static void PrintTriangle(int n)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= i; j++)
            {
                Console.Write($"{j} ");
            }
            Console.WriteLine();
        }
    }
}

--------------------------------------------------------------------

Изберете липсващата фраза, така че да дефинирате правилно понятието:
______________________________ наричаме такава операция, която възпрепятства продължението на изпълнение на програмата до приключване на съответната операция.


Изберете едно
a.
блокираща<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

b.
конкурентна

c.
асинхронна

d.
паралелна

--------------------------------------------------------------------

Демонстрирайте синхронизацията на нишки, чрез създаване на синхронизиращ обект и оператора lock в кода по-долу, така че стойността на брояча да е правилна и да се избягва проблема „състояние на гонка“ (race condition).

class Counter {

  public int Count { get; private set; }

  public void Increment() {

    Count++;

  }

  public void Decrement() {

    Count--;

  }

  static void TestCounter(Counter c)

  {

     for(int i = 0; i < 10000; i++)

     {

       c.Increment();

       c.Decrement();

     }

  }

}

class Program {

  public static void Main(string[] args) {

    Counter c = new Counter();

    Thread t1 = new Thread( () => TestCounter(c) );

    Thread t2 = new Thread( () => TestCounter(c) );

    Thread t3 = new Thread( () => TestCounter(c) );

    t1.Start();

    t2.Start();

    t3.Start();

    t1.Join();

    t2.Join();

    t3.Join();

  }

}

ВЕРНИЯ ОТГОВОР Е:

using System;
using System.Threading;

class Counter
{
    private readonly object lockObject = new object();

    public int Count { get; private set; }

    public void Increment()
    {
        lock (lockObject)
        {
            Count++;
        }
    }

    public void Decrement()
    {
        lock (lockObject)
        {
            Count--;
        }
    }

    static void TestCounter(Counter c)
    {
        for (int i = 0; i < 10000; i++)
        {
            c.Increment();
            c.Decrement();
        }
    }

    static void Main(string[] args)
    {
        Counter c = new Counter();

        Thread t1 = new Thread(() => TestCounter(c));
        Thread t2 = new Thread(() => TestCounter(c));
        Thread t3 = new Thread(() => TestCounter(c));

        t1.Start();
        t2.Start();
        t3.Start();

        t1.Join();
        t2.Join();
        t3.Join();

        Console.WriteLine($"Count: {c.Count}");
    }
}

--------------------------------------------------------------------

Посочете вярното твърдение за нишка


Изберете едно
a.
Нишките имат самостоятелни ресурси

b.
Всяка програма има по две нишки - на преден и заден план

c.
Нишките могат да се изпълняват конкурентно<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

d.
Нишките се стартират за изпълнение автоматично при създаването на обекта

--------------------------------------------------------------------

Кой е проблемът, който отговаря на посоченото описание?
Проблемът може да възникне по следния начин:

Нишка 1 заема ресурс А;

Нишка 2 заема ресурс B;

Нишка 1 опитва да заеме ресурс B;

Нишка 2 опитва да заеме ресурс А.

Тъй като ресурсите А и Б вече се използват съответно от нишка 1 и нишка 2, при опит на другата нишка да заеме ресурс, 
то тя трябва да изчака. Това води до взаимно изчакване и на двете нишки, което може да продължи безкрайно. Проблемът е възможно да възникне и между по-голям брой ресурси.

Правилният отговор е: Мъртва хватка (dead lock)

--------------------------------------------------------------------

Посочете грешното твърдение за нишка.

Изберете едно
a.
Програмите могат да имат нишки на преден и заден план

b.
Всеки процес има поне една нишка

c.
Нишките се стартират за изпълнение чрез метод .Start()

d.
Нишките имат самостоятелни ресурси<<<<<<<<<<<<<<<<<<<


--------------------------------------------------------------------

Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. Включете целия необходим код в отговора, в това число class Program и Main метод.


static void SayHello() {

    Console.WriteLine("Hello");

}

ВЕРНИЯ ОТГОВОР Е:

using System;
using System.Threading;

class Program
{
    static void SayHello()
    {
        Console.WriteLine("Hello");
    }

    static void Main(string[] args)
    {
        Thread t = new Thread(SayHello);
        t.Start();

        // Изчакваме нишката да завърши изпълнението си
        t.Join();

        Console.WriteLine("Main thread finished");
    }
}

--------------------------------------------------------------------

Дайте пример за ситуация, в която възниква проблем „състояние на гонка“ (race condition)?

using System;
using System.Threading;

class Program
{
    static int counter = 0;

    static void IncrementCounter()
    {
        for (int i = 0; i < 1000000; i++)
        {
            counter++;
        }
    }

    static void Main(string[] args)
    {
        Thread t1 = new Thread(IncrementCounter);
        Thread t2 = new Thread(IncrementCounter);

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine("Counter value: " + counter);
    }
} ------ В Този пример имаме глобална променлива counter, която две нишки t1 и t2 инкрементират 1 милион пъти в цикъл. 
Очакването може да е, че след като и двете нишки завършат изпълнението си, стойността на counter ще бъде 2 милиона.

--------------------------------------------------------------------

Изберете дефиницията на понятието процес


Изберете едно
a.
Процесът е обект, който операционната система изпълнява, за да поддържа своите функции

b.
Процесът е файла, който съдържа изпълнимия код на програмата

c.
Процесът е абстракция на програма в режим на изпълнение<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

d.
Процесът е набор от инструкции в една програма

--------------------------------------------------------------------

Опишете връзката между процес и нишка

Процесът и нишката са две основни концепции в многонишковото програмиране и операционните системи.
Връзката между процеса и нишката е следната:

Един процес може да има множество нишки, които работят паралелно и съвместно използват ресурсите на процеса.

--------------------------------------------------------------------

На кой от редовете се създава правилно обект за нишка, който изпълнява метод MyMethod без параметри?

Изберете едно
a.
var Thread t1 = new Thread(MyMethod);

b.
var thread = MyMethod();

c.
Thread thread = new Thread(MyMethod);<<<<<<<<<<<<<<<<<<<<<<<<<<

d.
Нито едно от посочените.

--------------------------------------------------------------------

Дефинирайте понятието конкурентност.

Конкурентност (Concurrency) е свойство на система или програма, при което няколко изчислителни задачи могат да напредват или да бъдат изпълнявани паралелно и независимо една от друга. 

--------------------------------------------------------------------

Дефинирайте понятието блокираща операция.

Блокираща операция (Blocking Operation) е операция, която временно спира изпълнението на текущия процес или нишка, докато се изпълни определено условие или събитие.

--------------------------------------------------------------------

Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. Включете целия необходим код в отговора, в това число class Program и Main метод.


static void Count() {

    for(int i = 5; i >= 0; i--) {

        Console.WriteLine(i);

    }

}

ВЕРНИЯ ОТГОВОР Е:

using System;
using System.Threading;

class Program
{
    static void Count()
    {
        for (int i = 5; i >= 0; i--)
        {
            Console.WriteLine(i);
        }
    }

    static void Main(string[] args)
    {
        Thread thread = new Thread(Count);
        thread.Start();
    }
}

--------------------------------------------------------------------

Изберете дефиницията на понятието конкурентност:


Изберете едно
a.
Изпълнение на приоритетен набор от операции

b.
Изпълнение на набор от операции последователно

c.
Изпълнение на набор от операции при успешното приключване на дадена операция

d.
Изпълнение на набор от операции едновременно<<<<<<<<<<<<<<<<<<<<<<<<<<

--------------------------------------------------------------------

Дефиницията „Самостоятелна редица от програмни инструкции, които се изпълняват последователно” е на понятието


Изберете едно
a.
конкурентност

b.
асинхронност

c.
нишка<<<<<<<<<<<<<<<<<<<<<<<<<<<<

d.
процес

--------------------------------------------------------------------

Кое от следните е метод за прекъсване на работата на Thread обект?

Изберете едно
a. Suspend<<<<<<<<<<<<<<<<<<<<<<<<<
b.
Start

c.
Join

d.
Stop

--------------------------------------------------------------------

Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. Включете целия необходим код в отговора, в това число class Program и Main метод.


static void PrintBunny() {

    Console.WriteLine(@"|)___(|");
    Console.WriteLine(@"(o . o)");
    Console.WriteLine(@"(_).(_)");

}

ВЕРНИЯ ОТГОВОР Е:

using System;
using System.Threading;

class Program
{
    static void PrintBunny()
    {
        Console.WriteLine(@"|)___(|");
        Console.WriteLine(@"(o . o)");
        Console.WriteLine(@"(_).(_)");
    }

    static void Main(string[] args)
    {
        Thread thread = new Thread(PrintBunny);
        thread.Start();
    }
}

--------------------------------------------------------------------

Кой е проблемът, който отговаря на посоченото описание?
Това състояние на нишка е свързано с ресурсите, които получават нишките. Нека имаме нишка А, която използва общ ресурс с друга нишка, но често го задържа за себе си за по-дълго време. Нишка Б получава ресурса на цената на дълго чакане.

Правилният отговор е: Гладуване (starvation)

--------------------------------------------------------------------

Между процесите и нишките съществува връзка. Кое от тези твърдения описва вярно тази връзка?


Изберете едно
a.
множество нишки на различни програми може да бъдат изпълнявани от даден процес<<<<<<<<<<<<<<<<<<<<<<<<<<<

b.
процесът може да изпълнява само една нишка

c.
процесът може да изпълнява множество нишки, които имат самостоятелна памет

d.
процесът може да изпълнява множество нишки, които имат споделена памет

--------------------------------------------------------------------

Какви са приликите и разликите между асинхронно програмиране и многонишковото програмиране?

Прилики между асинхронно програмиране и многонишковото (паралелно) програмиране:

Позволяват изпълнение на задачи едновременно: И двете техники целят изпълнение на задачи паралелно или конкурентно, за да подобрят ефективността и отзивчивостта на приложението.

Разлики между асинхронното програмиране и многонишковото програмиране:

Модел на изпълнение: В асинхронното програмиране задачите се изпълняват на една или малък брой нишки, които се управляват от операционната система или средата за изпълнение.


--------------------------------------------------------------------

Кое от следните НЕ е състояние на нишка?


Изберете едно
a.
„незапочната” (Unstarted)

b.
„в изпълнение” (Running)

c.
„подлежаща на изпълнение” (Runnable)

d.
„в изчакване” (Awaiting)<<<<<<<<<<<<<<<<<<<<<<

--------------------------------------------------------------------

Кое от понятията е дефинирано в текста по-долу?

Изпълнение на набор от операции едновременно.


Изберете едно
a.
нишка<<<<<<<<<<<<<<<<<<<<<<<<<<

b.
процес

c.
задача

d.
конкурентност

--------------------------------------------------------------------

Попълнете липсващите места в текста с подходящи думи, така че да опишете връзката между процес и нишка.
А. [Процесът] може да притежава многобройни Б. [Нишки]. Те В. [споделят общи ] ресурси. Програма, която може да изпълнява едновременно няколко редици от програмни инструкции наричаме Г. [многонишкова програма].

--------------------------------------------------------------------

Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. Включете целия необходим код в отговора, в това число class Program и Main метод.


static void SayHello(string name) {

    Console.WriteLine($"Hello, {name}!");

}

ВЕРНИЯ ОТГОВОР Е:

using System;
using System.Threading;

class Program
{
    static void SayHello(string name)
    {
        Console.WriteLine($"Hello, {name}!");
    }

    static void Main(string[] args)
    {
        // Създаване на нишка
        Thread thread = new Thread(() => SayHello("John"));

        // Стартиране на нишката
        thread.Start();

        // Изчакване нишката да завърши изпълнението си
        thread.Join();
    }
}

--------------------------------------------------------------------

Изберете дефиницията на понятието нишка.

Изберете едно
a.
Свързани редици от програмни инструкции, за които се определя приоритет на реда на изпълнение

b.
Свързани редици от програмни инструкции, които се изпълняват паралелно

c.
Самостоятелна редица от програмни инструкции, които се изпълняват паралелно

d.
Самостоятелна редица от програмни инструкции, които се изпълняват последователно<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

--------------------------------------------------------------------








































































































































































































